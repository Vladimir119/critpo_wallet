# critpo_wallet

## Цель:
Отправить от пользователя серверу шифрованное сообщение бакета с адрессами кошельков, что бы получить от сервера информаию о своих кошельках, так что бы сервер сам незнал, какие кошельки из его ответ принадлежат пользователю. 

## Важно:
1. Кошельки соответствующие адрессам, запрашиваемым пользователем, должны присутствовать в ответе сервера. 
2. Сервер не должен знать какие именно кошельки из ответа принадлежат пользователю, запрашивающему кошельки. Поэтому он подмешивает в ответ кошельки других пользователей. 
3. Подмешиваемые кошельки должны должны быть не изменяемыми при неизменяймом запросе. То есть если пользователь 2 раза запришивает одни и теже аддреса, то он получает 2 одинаквых набора кошельков. 

## Идея:
Пользователь и сервер синхранизирует набор из k хеш функций. Сервер хранит блум фильтры полученные хешированием адресов с помощью синхронизированных хеш функций. Каждому адресу соответствует свой блум фильтр. <br>
Пользователь хочет запросить сразу пачку из r адресов. Он логически суммирует все фильтры блума соответствующие этим адресам(операция OR), после чего подмешивает туда еще случайно $l$ едениц(случайность подрузумевается в том
 смысле, что он делает один раз случайно, а позже запоминает растоновку случайно добавленных едениц и всегда использует их).Пользователь для одного бакета лишь раз считает l и фиксирует l едениц, далее(при последующих запросах)
  он использует уже насчитанные значения $l$  и позиции едениц. Помимо того, $l$ псевдо случайно добавленных едениц могут накладыаться на уже стоящие еденице в блуме, 
   мы ничего с этим не делаем, просто оставляем уже стоящую еденицу, и перехождим к следующей псевдо случайной еденицы. По итогу у пользователя сформируется битовая маска сопоставленная каждому из его бакетов с адресами(каждая маска формируется в момент первого запроса этого бакета к бд). 
   Именно через эти маскм пользователь будет общаться с сервером. <br>
    Когда пользоателю нужно получить информацию по адресам в бакете, он сначала запрашивает текущий размер БД(кол-во токенов в бд/кол-во адресов по всем пользователям), с помощью него он считает параметр $l$, далее он формирует битовую маску и отправляет ее серверу. Сервер в свою очередь
    сперва отправляет пользователю размер БД, а после того как он получат битовую маску. Он с помощью индексов ополучает из БД маски всех аддресов которые являются подмножеством маски пользователя и возврощает ему часть этого, а именно столько сколько возвращал в превый раз(так как после увеличения БД
    мы кол-во масок которые являются подмножеством нашей растет.)
